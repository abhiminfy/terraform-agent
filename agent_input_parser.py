# Full updated agent_input_parser.py
import os
import re
import shutil
import subprocess
from pathlib import Path
from dotenv import load_dotenv
import google.generativeai as genai

# Load environment variables
load_dotenv()
API_KEY = os.getenv("GOOGLE_API_KEY")
if not API_KEY:
    raise RuntimeError("Missing GOOGLE_API_KEY in your .env file.")

# Configure the Gemini API
genai.configure(api_key=API_KEY)
model = genai.GenerativeModel("models/gemini-1.5-pro-latest")
chat = model.start_chat(history=[])

# Initial system message to guide the assistant
chat.send_message("""
You are an AI DevOps assistant. You:
1. Act like a normal chatbot unless the user mentions infra/infrastructure or cloud deployment.
2. When infra is requested, ask clarifying questions if the requirements are incomplete.
3. Then generate clean Terraform code based on the user's clarified needs.
""")

# Highlight/patch sensitive values in Terraform
def highlight_placeholders(terraform_code: str) -> str:
    substitutions = {
        r'ami\s*=\s*".+?"': 'ami = "ami-09ac0b140f63d3458"',
        r'username\s*=\s*".+?"': 'username = "adminuser"',
        r'password\s*=\s*".+?"': 'password = "MyS3cur3P@ssw0rd!"',
        r'db_name\s*=\s*".+?"': 'db_name = "terraform-db"',
        r'identifier\s*=\s*".+?"': 'identifier = "terraform-mysql-db"',
        r'key_name\s*=\s*".+?"': 'key_name = "terraform-key"',
        r'subnet_id\s*=\s*".+?"': 'subnet_id = "subnet-xxxxxx"',
        r'vpc_security_group_ids\s*=\s*\[.+?\]': 'vpc_security_group_ids = ["sg-xxxxxx"]',
        r'availability_zone\s*=\s*".+?"': 'availability_zone = "us-east-1a"',
        r'file\("~/.ssh/id_rsa.pub"\)': '"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD..."'
    }
    for pattern, replacement in substitutions.items():
        terraform_code = re.sub(pattern, replacement, terraform_code)
    return terraform_code

# Extract Terraform code from AI response
def extract_terraform_code(response_text: str) -> str:
    matches = re.findall(r"```(?:terraform|hcl)?\n(.*?)```", response_text, re.DOTALL)
    if matches:
        return matches[0].strip()
    return re.sub(r"[*`#>]", "", response_text).strip()

# Estimate cost using Infracost
def estimate_infracost() -> str:
    for exe in ["terraform", "infracost"]:
        if shutil.which(exe) is None:
            raise RuntimeError(f"Required executable '{exe}' not found. Please install it.")

    subprocess.run(["terraform", "init", "-input=false"], check=True)
    subprocess.run(["terraform", "plan", "-out=tfplan.binary"], check=True)

    with open("tfplan.json", "w", encoding="utf-8") as f:
        subprocess.run(["terraform", "show", "-json", "tfplan.binary"], stdout=f, check=True)

    result = subprocess.run(
        ["infracost", "breakdown", "--path=tfplan.json", "--format=table"],
        capture_output=True, text=True, check=True
    )

    return result.stdout.strip() if result.stdout else "Infracost returned empty output."

# Push Terraform code to GitHub
def push_to_github() -> str:
    github_token = os.getenv("GITHUB_TOKEN")
    github_repo = os.getenv("GITHUB_REPO")
    if not github_token or not github_repo:
        return "GitHub push skipped: Missing GITHUB_TOKEN or GITHUB_REPO"

    repo_url = f"https://{github_token}@github.com/{github_repo}.git"

    Path(".gitignore").write_text("""\
.terraform/
*.tfstate
*.tfstate.backup
.tfplan
tfplan.*
tfplan.json
__pycache__/
*.pyc
*.pyo
*.pyd
env/
venv/
.vscode/
.DS_Store
Thumbs.db
""")

    try:
        if not Path(".git").exists():
            subprocess.run(["git", "init"], check=True)
            subprocess.run(["git", "remote", "add", "origin", repo_url], check=True)
        else:
            subprocess.run(["git", "remote", "set-url", "origin", repo_url], check=True)

        subprocess.run(["git", "add", "."], check=True)
        subprocess.run(["git", "commit", "-m", "Auto-push: Terraform code generated by AI"], check=True)
        subprocess.run(["git", "branch", "-M", "main"], check=True)
        subprocess.run(["git", "push", "-u", "origin", "main"], check=True)

        return "âœ… Code pushed successfully to GitHub."
    except Exception as e:
        return f"GitHub push failed:\n{str(e)}"

# Identify if user prompt is infra-related
def is_infra_prompt(user_prompt: str) -> bool:
    keywords = ["infrastructure", "terraform", "vpc", "ec2", "s3", "rds", "alb", "cloud setup", "provision"]
    return any(k in user_prompt.lower() for k in keywords)

# Generate follow-up clarification questions
def ask_for_clarity(user_prompt: str) -> str:
    clarify_prompt = (
        "You are a helpful cloud infrastructure assistant. "
        f"If the user prompt is vague, ask 2-3 follow-up questions to clarify:\n\nPrompt: {user_prompt}\n\n"
        "Return only numbered questions."
    )
    response = model.generate_content(clarify_prompt)
    return response.text.strip()

# MAIN handler
def process_user_prompt(user_prompt: str) -> dict:
    try:
        if is_infra_prompt(user_prompt):
            infra_response = model.generate_content(user_prompt).text
            raw_code = extract_terraform_code(infra_response)

            if not re.search(r'\bresource\b|\bprovider\b|\bmodule\b', raw_code):
                questions = ask_for_clarity(user_prompt)
                return {"type": "clarify", "content": questions}

            final_code = highlight_placeholders(raw_code)
            Path("main.tf").write_text(final_code, encoding="utf-8")
            cost = estimate_infracost()
            git_result = push_to_github()

            return {
                "type": "terraform",
                "terraform_code": final_code,
                "cost_estimate": cost,
                "github_status": git_result
            }

        else:
            general_reply = model.generate_content(user_prompt).text.strip()
            return {"type": "chat", "content": general_reply}

    except Exception as e:
        return {"type": "error", "error": str(e)}
