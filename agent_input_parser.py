import os
import re
import shutil
import subprocess
from pathlib import Path

import google.generativeai as genai
from dotenv import load_dotenv

# ---------- 0. Load env & configure Gemini ----------
load_dotenv()

API_KEY = os.getenv("GOOGLE_API_KEY")
if not API_KEY:
    raise RuntimeError("‚ùå Missing GOOGLE_API_KEY in your .env file.")

genai.configure(api_key=API_KEY)
model = genai.GenerativeModel("gemini-1.5-pro")


# ---------- 1. CLI dependency check ----------
def require_executable(name: str) -> None:
    if shutil.which(name) is None:
        raise RuntimeError(f"‚ùå Required executable '{name}' not found. Please install it.")


# ---------- 2. Placeholder patching ----------
def highlight_placeholders(terraform_code: str) -> str:
    substitutions = {
        r'ami\s*=\s*".+?"': 'ami = "ami-09ac0b140f63d3458"',
        r'username\s*=\s*".+?"': 'username = "adminuser"',
        r'password\s*=\s*".+?"': 'password = "MyS3cur3P@ssw0rd!"',
        r'db_name\s*=\s*".+?"': 'db_name = "terraform-db"',
        r'identifier\s*=\s*".+?"': 'identifier = "terraform-mysql-db"',
        r'key_name\s*=\s*".+?"': 'key_name = "terraform-key"',
        r'subnet_id\s*=\s*".+?"': 'subnet_id = "subnet-xxxxxx"',
        r'vpc_security_group_ids\s*=\s*\[.+?\]': 'vpc_security_group_ids = ["sg-xxxxxx"]',
        r'availability_zone\s*=\s*".+?"': 'availability_zone = "us-east-1a"',
    }
    for pattern, replacement in substitutions.items():
        terraform_code = re.sub(pattern, replacement, terraform_code)
    return terraform_code


# ---------- 3. Infracost estimation ----------
def estimate_infracost() -> str:
    try:
        subprocess.run(["terraform", "init", "-input=false"], check=True)
        
        plan = subprocess.run(
            ["terraform", "plan", "-out=tfplan.binary"],
            capture_output=True,
            text=True
        )
        if plan.returncode != 0:
            return f"‚ùå terraform plan failed:\n{plan.stderr or plan.stdout}"

        subprocess.run(["terraform", "show", "-json", "tfplan.binary"], stdout=open("tfplan.json", "w"), check=True)

        result = subprocess.run(
            ["infracost", "breakdown", "--path=tfplan.json", "--format=table"],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout

    except subprocess.CalledProcessError as e:
        return f"‚ùå Infracost error:\n{e.stderr or str(e)}"
    except Exception as e:
        return f"‚ùå Unexpected error during cost estimation:\n{str(e)}"



# ---------- 4. Push to GitHub ----------
def push_to_github() -> str:
    github_token = os.getenv("GITHUB_TOKEN")
    github_repo = os.getenv("GITHUB_REPO")
    if not github_token or not github_repo:
        return "‚ö†Ô∏è GitHub push skipped: Missing GITHUB_TOKEN or GITHUB_REPO in .env"

    repo_url = f"https://{github_token}@github.com/{github_repo}.git"

    try:
        if not Path(".git").exists():
            subprocess.run(["git", "init"], check=True)
            subprocess.run(["git", "remote", "add", "origin", repo_url], check=True)
        else:
            subprocess.run(["git", "remote", "set-url", "origin", repo_url], check=True)

        subprocess.run(["git", "add", "."], check=True)
        subprocess.run(["git", "commit", "-m", "Auto-push: Terraform code generated by AI"], check=True)
        subprocess.run(["git", "branch", "-M", "main"], check=True)
        subprocess.run(["git", "push", "-u", "origin", "main"], check=True)

        return "‚úÖ Code pushed successfully to GitHub."
    except subprocess.CalledProcessError as e:
        return f"‚ùå GitHub push failed:\n{e.stderr or str(e)}"
    except Exception as e:
        return f"‚ùå Unexpected Git push error:\n{str(e)}"


# ---------- 5. Parse User Prompt ----------
def parse_user_input(user_prompt: str) -> tuple[str, str, str]:
    system_prompt = (
         "You are an expert Terraform DevOps assistant. "
    "Only use valid Terraform HCL code. Avoid using unsupported resources like aws_security_group_association. "
    "Use standard aws_* resources that are supported by the official AWS Terraform provider. "
    "DO NOT wrap code in markdown ``` blocks. "
    "Just return plain Terraform code."
    )

    # üßπ Clean previous files
    for f in Path(".").glob(".terraform*"):
        shutil.rmtree(f, ignore_errors=True) if f.is_dir() else f.unlink(missing_ok=True)
    for f in ("terraform.tfstate", "terraform.tfstate.backup", "main.tf", "tfplan.binary", "tfplan.json"):
        Path(f).unlink(missing_ok=True)

    # ‚úÖ Check dependencies
    require_executable("terraform")
    require_executable("infracost")
    require_executable("git")

    try:
        response = model.generate_content([
            {"role": "user", "parts": [system_prompt + "\n" + user_prompt]}
        ])
        raw_code = response.text

        # Clean output
        raw_code = re.sub(r"```(?:terraform|hcl)?\n(.*?)```", r"\1", raw_code, flags=re.DOTALL).strip()
        raw_code = raw_code.split("```")[0].strip()

        # Remove known bad resource types
        raw_code = re.sub(r'resource\s+"aws_security_group_association".*?\{.*?\}\n?', "", raw_code, flags=re.DOTALL)

        # Patch values & save
        cleaned_code = highlight_placeholders(raw_code)
        Path("main.tf").write_text(cleaned_code, encoding="utf-8")

        # Run cost + git
        cost_output = estimate_infracost()
        git_output = push_to_github()

        return cleaned_code, cost_output, git_output

    except Exception as e:
        raise RuntimeError(f"‚ùå Error: {str(e)}")


