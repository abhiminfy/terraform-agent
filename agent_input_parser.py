import os
import re
import shutil
import subprocess
from pathlib import Path
from dotenv import load_dotenv
from typing import Tuple  #  Added for thinking trace
import google.generativeai as genai

# Load environment variables
load_dotenv()
API_KEY = os.getenv("GOOGLE_API_KEY")
if not API_KEY:
    raise RuntimeError("Missing GOOGLE_API_KEY in .env file.")

# Configure Gemini API
genai.configure(api_key=API_KEY)
model = genai.GenerativeModel("models/gemini-1.5-pro-latest")
chat = model.start_chat(history=[])

# Add system guidance message
chat.send_message("""
You are an AI DevOps assistant. You:
1. Act like a normal chatbot unless the user mentions infra/infrastructure or cloud deployment.
2. When infra is requested, ask clarifying questions if the requirements are incomplete.
3. Then generate clean Terraform code based on the user's clarified needs.
""")

# Replace sensitive values in Terraform
def highlight_placeholders(terraform_code: str) -> str:
    substitutions = {
        r'ami\s*=\s*".+?"': 'ami = "ami-09ac0b140f63d3458"',
        r'username\s*=\s*".+?"': 'username = "adminuser"',
        r'password\s*=\s*".+?"': 'password = "MyS3cur3P@ssw0rd!"',
        r'db_name\s*=\s*".+?"': 'db_name = "terraform-db"',
        r'identifier\s*=\s*".+?"': 'identifier = "terraform-mysql-db"',
        r'key_name\s*=\s*".+?"': 'key_name = "terraform-key"',
        r'subnet_id\s*=\s*".+?"': 'subnet_id = "subnet-xxxxxx"',
        r'vpc_security_group_ids\s*=\s*\[.+?\]': 'vpc_security_group_ids = ["sg-xxxxxx"]',
        r'availability_zone\s*=\s*".+?"': 'availability_zone = "us-east-1a"',
        r'file\("~/.ssh/id_rsa.pub"\)': '"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD..."'
    }
    for pattern, replacement in substitutions.items():
        terraform_code = re.sub(pattern, replacement, terraform_code)
    return terraform_code

# Extract Terraform from response
def extract_terraform_code(response_text: str) -> str:
    matches = re.findall(r"```(?:terraform|hcl)?\n(.*?)```", response_text, re.DOTALL)
    return matches[0].strip() if matches else re.sub(r"[*`#>]", "", response_text).strip()

# Estimate infra cost using Infracost
def estimate_infracost() -> str:
    for exe in ["terraform", "infracost"]:
        if shutil.which(exe) is None:
            raise RuntimeError(f"Executable '{exe}' not found. Please install it.")

    subprocess.run(["terraform", "init", "-input=false"], check=True)
    subprocess.run(["terraform", "plan", "-out=tfplan.binary"], check=True)
    subprocess.run(["terraform", "show", "-json", "tfplan.binary"], stdout=open("tfplan.json", "w"), check=True)

    result = subprocess.run(
        ["infracost", "breakdown", "--path=tfplan.json", "--format=table"],
        capture_output=True, text=True, check=True
    )
    return result.stdout.strip() if result.stdout else "Infracost returned no output."

# Push to GitHub
def push_to_github() -> str:
    github_token = os.getenv("GITHUB_TOKEN")
    github_repo = os.getenv("GITHUB_REPO")
    if not github_token or not github_repo:
        return "GitHub push skipped: Missing GITHUB_TOKEN or GITHUB_REPO"

    repo_url = f"https://{github_token}@github.com/{github_repo}.git"

    Path(".gitignore").write_text("""\
.terraform/
*.tfstate
*.tfstate.backup
.tfplan
tfplan.*
tfplan.json
__pycache__/
*.pyc
*.pyo
*.pyd
env/
venv/
.vscode/
.DS_Store
Thumbs.db
""")

    try:
        if not Path(".git").exists():
            subprocess.run(["git", "init"], check=True)
        subprocess.run(["git", "remote", "set-url", "origin", repo_url], check=True)
        subprocess.run(["git", "add", "."], check=True)
        subprocess.run(["git", "commit", "-m", "Auto-push: Terraform code generated by AI"], check=True)
        subprocess.run(["git", "branch", "-M", "main"], check=True)
        subprocess.run(["git", "push", "-u", "origin", "main"], check=True)

        return "✅ Code pushed to GitHub successfully."
    except Exception as e:
        return f"GitHub push failed: {str(e)}"

#  Detect infrastructure intent
def is_infra_prompt(user_prompt: str) -> bool:
    user_prompt_lower = user_prompt.lower()
    keywords = ["vpc", "ec2", "s3", "rds", "alb", "cloud setup", "provision", "infrastructure"]
    verbs = ["create", "build", "setup", "provision", "deploy", "generate", "spin up"]

    if any(k in user_prompt_lower for k in keywords):
        if any(v in user_prompt_lower for v in verbs):
            return True

    if "terraform" in user_prompt_lower and any(v in user_prompt_lower for v in verbs):
        return True

    return False

#  Ask for missing details
def ask_for_clarity(user_prompt: str) -> str:
    clarify_prompt = (
        "You are a helpful DevOps assistant. If the user prompt is vague, ask 2–3 clarification questions.\n\n"
        f"Prompt: {user_prompt}\n\nReturn only numbered questions."
    )
    resp = model.generate_content(clarify_prompt)
    return resp.text.strip() if hasattr(resp, "text") else "Could not generate clarification questions."

#  Generate agent reasoning + response
def get_reasoned_response(user_prompt: str) -> Tuple[str, str]:
    reason_prompt = f"""
You are a Terraform AI assistant.

When given a task, first explain your reasoning step-by-step (like you're thinking out loud).
Then generate the final answer.

User prompt: {user_prompt}

Respond in this format exactly:

THINKING:
<your reasoning>

FINAL RESPONSE:
<final output, such as Terraform code or answer>
"""
    response = model.generate_content(reason_prompt)
    full_text = response.text.strip()

    thinking = "Could not extract reasoning."
    final = "Could not extract final output."

    if "FINAL RESPONSE:" in full_text:
        thinking = full_text.split("FINAL RESPONSE:")[0].replace("THINKING:", "").strip()
        final = full_text.split("FINAL RESPONSE:")[1].strip()
    else:
        final = full_text

    return thinking, final

#  Main processing function
def process_user_prompt(user_prompt: str) -> dict:
    try:
        user_prompt = user_prompt.strip() if user_prompt else ""
        if not user_prompt:
            return {"type": "error", "error": "Prompt is empty."}

        if is_infra_prompt(user_prompt):
            thinking_trace, model_response = get_reasoned_response(user_prompt)
            raw_code = extract_terraform_code(model_response)

            if not re.search(r'\bresource\b|\bprovider\b|\bmodule\b', raw_code, re.IGNORECASE):
                questions = ask_for_clarity(user_prompt)
                return {
                    "type": "clarify",
                    "content": questions,
                    "thinking_trace": thinking_trace
                }

            final_code = highlight_placeholders(raw_code)
            Path("main.tf").write_text(final_code, encoding="utf-8")
            cost = estimate_infracost()
            git_result = push_to_github()

            return {
                "type": "terraform",
                "terraform_code": final_code,
                "cost_estimate": cost,
                "github_status": git_result,
                "thinking_trace": thinking_trace
            }

        else:
            thinking_trace, reply = get_reasoned_response(user_prompt)
            return {
                "type": "chat",
                "content": reply,
                "thinking_trace": thinking_trace
            }

    except Exception as e:
        return {"type": "error", "error": str(e)}
